name: Deploy App

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets and variables
        run: |
          echo "Checking required configuration..."
          missing=""

          # Check required secrets (we can only check if they're set, not their values)
          if [ -z "${{ secrets.APP_HOST }}" ]; then missing="$missing APP_HOST"; fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then missing="$missing SSH_USER"; fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then missing="$missing SSH_PRIVATE_KEY"; fi
          if [ -z "${{ secrets.POSTGRES_PASSWORD }}" ]; then missing="$missing POSTGRES_PASSWORD"; fi
          if [ -z "${{ secrets.NEO4J_PASSWORD }}" ]; then missing="$missing NEO4J_PASSWORD"; fi
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then missing="$missing JWT_SECRET"; fi

          # Check required variables
          if [ -z "${{ vars.DOMAIN }}" ]; then missing="$missing DOMAIN(var)"; fi
          if [ -z "${{ vars.ACME_EMAIL }}" ]; then missing="$missing ACME_EMAIL(var)"; fi

          if [ -n "$missing" ]; then
            echo "::error::Missing required configuration:$missing"
            echo "Please configure these in GitHub repository settings (Settings > Secrets and variables > Actions)"
            exit 1
          fi

          echo "✓ All required configuration present"

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 30m
          script: |
            set -e

            DEPLOY_DIR="/opt/chive"
            REPO_URL="https://github.com/chive-pub/chive.git"

            echo "=== Starting deployment ==="
            echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

            # Ensure /opt exists and is writable
            sudo mkdir -p /opt
            sudo chown $USER:$USER /opt 2>/dev/null || true

            # Clone or update repository
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Cloning repository for initial setup..."
              git clone "$REPO_URL" "$DEPLOY_DIR"
            elif [ ! -d "$DEPLOY_DIR/.git" ]; then
              echo "Directory exists but is not a git repo. Removing and cloning..."
              rm -rf "$DEPLOY_DIR"
              git clone "$REPO_URL" "$DEPLOY_DIR"
            else
              echo "Updating existing repository..."
              cd "$DEPLOY_DIR"
              git fetch origin main
              git reset --hard origin/main
            fi

            cd "$DEPLOY_DIR"
            echo "Current commit: $(git rev-parse --short HEAD) - $(git log -1 --format=%s)"

            # Ensure docker directory exists
            mkdir -p docker

            # Create .env.production from secrets
            echo "Writing environment configuration..."
            cat > docker/.env.production << 'ENVEOF'
            # Domain configuration
            DOMAIN=${{ vars.DOMAIN }}
            ACME_EMAIL=${{ vars.ACME_EMAIL }}
            CHIVE_VERSION=latest

            # Database credentials
            POSTGRES_DB=chive
            POSTGRES_USER=chive
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            NEO4J_USER=neo4j
            NEO4J_PASSWORD=${{ secrets.NEO4J_PASSWORD }}

            # Redis
            REDIS_URL=redis://redis:6379

            # Application secrets
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}

            # Governance PDS
            GOVERNANCE_PDS_JWT_SECRET=${{ secrets.GOVERNANCE_PDS_JWT_SECRET }}
            GOVERNANCE_PDS_ADMIN_PASSWORD=${{ secrets.GOVERNANCE_PDS_ADMIN_PASSWORD }}
            GOVERNANCE_PDS_ROTATION_KEY=${{ secrets.GOVERNANCE_PDS_ROTATION_KEY }}

            # Database URLs
            DATABASE_URL=postgresql://chive:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/chive
            ELASTICSEARCH_URL=http://elasticsearch:9200
            NEO4J_URL=bolt://neo4j:7687

            # ATProto
            ATPROTO_SERVICE_DID=${{ vars.ATPROTO_SERVICE_DID }}
            ATPROTO_RELAY_URL=wss://bsky.network

            # Email (Amazon WorkMail)
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USER=${{ secrets.SMTP_USER }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            EMAIL_FROM=${{ vars.EMAIL_FROM }}

            # Zulip
            ZULIP_SERVER_URL=${{ vars.ZULIP_SERVER_URL }}
            ZULIP_BOT_EMAIL=${{ secrets.ZULIP_BOT_EMAIL }}
            ZULIP_BOT_API_KEY=${{ secrets.ZULIP_BOT_API_KEY }}
            ZULIP_INVITE_URL=${{ secrets.ZULIP_INVITE_URL }}

            # Traefik (generate with: echo $(htpasswd -nb admin password) | sed -e s/\\$/\\$\\$/g)
            TRAEFIK_BASIC_AUTH=${{ secrets.TRAEFIK_BASIC_AUTH }}
            ENVEOF

            # Build and deploy
            echo "=== Building and deploying containers ==="
            cd docker

            # Pull latest base images
            echo "Pulling latest base images..."
            docker compose -f docker-compose.prod.yml pull postgres redis elasticsearch neo4j traefik || true

            # Build the main chive image (API + Indexer)
            echo "Building main chive image..."
            docker build -t chive:latest -f ../docker/Dockerfile .. || {
              echo "::error::Failed to build main chive image"
              exit 1
            }

            # Build web container
            echo "Building chive-web container..."
            docker compose -f docker-compose.prod.yml build chive-web || {
              echo "::error::Failed to build chive-web image"
              exit 1
            }

            # Build docs container
            echo "Building chive-docs container..."
            docker compose -f docker-compose.prod.yml build chive-docs || {
              echo "::warning::Failed to build chive-docs image (non-fatal)"
            }

            # Start all services
            echo "Starting services..."
            docker compose -f docker-compose.prod.yml up -d

            # Wait for services to initialize
            echo "Waiting for services to initialize..."
            sleep 30

            # Show running containers
            echo "=== Container status ==="
            docker compose -f docker-compose.prod.yml ps

            # Check for any failed containers
            failed=$(docker compose -f docker-compose.prod.yml ps --status exited --format json 2>/dev/null | grep -c '"State":"exited"' || echo "0")
            if [ "$failed" != "0" ]; then
              echo "::warning::Some containers may have exited"
              docker compose -f docker-compose.prod.yml logs --tail=50 2>&1 | head -100
            fi

            # Cleanup old images
            echo "Cleaning up old images..."
            docker system prune -f

            echo "=== Deployment complete ==="
            echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      - name: Setup Governance PDS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 5m
          script: |
            set -e

            DOMAIN="${{ vars.DOMAIN }}"
            PDS_CONTAINER="chive-governance-pds"
            GOVERNANCE_HANDLE="governance.${DOMAIN}"
            GOVERNANCE_EMAIL="governance@${DOMAIN}"

            echo "=== Governance PDS Setup ==="

            cd /opt/chive/docker

            # Wait for PDS to be healthy
            echo "Waiting for Governance PDS to be healthy..."
            for i in {1..30}; do
              if docker exec ${PDS_CONTAINER} wget -q --spider http://localhost:3000/xrpc/_health 2>/dev/null; then
                echo "✓ Governance PDS is healthy"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "::warning::Governance PDS not healthy after 60s - skipping account setup"
                exit 0
              fi
              sleep 2
            done

            # Check if governance account already exists by trying to resolve the handle
            echo "Checking if governance account exists..."
            EXISTING_DID=$(docker exec ${PDS_CONTAINER} sh -c "
              wget -q -O- 'http://localhost:3000/xrpc/com.atproto.identity.resolveHandle?handle=${GOVERNANCE_HANDLE}' 2>/dev/null || echo ''
            " | grep -o '"did":"[^"]*"' | cut -d'"' -f4 || echo "")

            if [ -n "$EXISTING_DID" ] && [ "$EXISTING_DID" != "" ]; then
              echo "✓ Governance account already exists"
              echo "  DID: ${EXISTING_DID}"
              echo "  Handle: ${GOVERNANCE_HANDLE}"
              exit 0
            fi

            # Create governance account using pdsadmin
            echo "Creating governance account..."
            echo "  Handle: ${GOVERNANCE_HANDLE}"
            echo "  Email: ${GOVERNANCE_EMAIL}"

            # Check if pdsadmin exists
            if docker exec ${PDS_CONTAINER} test -f /pds/pdsadmin.sh; then
              RESULT=$(docker exec ${PDS_CONTAINER} /pds/pdsadmin.sh account create "${GOVERNANCE_HANDLE}" "${GOVERNANCE_EMAIL}" 2>&1) || {
                echo "::warning::Failed to create governance account"
                echo "$RESULT"
                exit 0
              }
              echo "$RESULT"

              # Try to extract DID
              NEW_DID=$(echo "$RESULT" | grep -o 'did:plc:[a-z0-9]*' | head -1 || echo "")
              if [ -n "$NEW_DID" ]; then
                echo ""
                echo "✓ Governance account created!"
                echo "  DID: ${NEW_DID}"
                echo "  Handle: ${GOVERNANCE_HANDLE}"
              fi
            else
              echo "::warning::pdsadmin.sh not found in container - manual setup may be required"
            fi

      - name: Verify deployment
        if: ${{ vars.DOMAIN != '' }}
        run: |
          echo "Waiting for services to fully start..."
          sleep 60

          domain="${{ vars.DOMAIN }}"
          success=true

          echo "Checking API health at https://$domain/api/health..."
          if curl -sf --max-time 30 "https://$domain/api/health"; then
            echo "✓ API health check passed"
          else
            echo "✗ API health check failed"
            success=false
          fi

          echo ""
          echo "Checking web frontend at https://$domain/..."
          if curl -sf --max-time 30 "https://$domain/" > /dev/null; then
            echo "✓ Web health check passed"
          else
            echo "✗ Web health check failed"
            success=false
          fi

          echo ""
          echo "Checking docs at https://docs.$domain/..."
          if curl -sf --max-time 30 "https://docs.$domain/" > /dev/null; then
            echo "✓ Docs health check passed"
          else
            echo "⚠ Docs health check failed (non-critical)"
          fi

          echo ""
          if [ "$success" = "false" ]; then
            echo "::warning::Some health checks failed. Check container logs on the server."
          else
            echo "All critical health checks passed!"
          fi
