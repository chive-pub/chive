name: Deploy App

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets and variables
        run: |
          echo "Checking required configuration..."
          missing=""

          # Check required secrets (we can only check if they're set, not their values)
          if [ -z "${{ secrets.APP_HOST }}" ]; then missing="$missing APP_HOST"; fi
          if [ -z "${{ secrets.SSH_USER }}" ]; then missing="$missing SSH_USER"; fi
          if [ -z "${{ secrets.SSH_PRIVATE_KEY }}" ]; then missing="$missing SSH_PRIVATE_KEY"; fi
          if [ -z "${{ secrets.POSTGRES_PASSWORD }}" ]; then missing="$missing POSTGRES_PASSWORD"; fi
          if [ -z "${{ secrets.NEO4J_PASSWORD }}" ]; then missing="$missing NEO4J_PASSWORD"; fi
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then missing="$missing JWT_SECRET"; fi
          if [ -z "${{ secrets.GRAFANA_ADMIN_PASSWORD }}" ]; then missing="$missing GRAFANA_ADMIN_PASSWORD"; fi

          # Check required variables
          if [ -z "${{ vars.DOMAIN }}" ]; then missing="$missing DOMAIN(var)"; fi
          if [ -z "${{ vars.ACME_EMAIL }}" ]; then missing="$missing ACME_EMAIL(var)"; fi

          if [ -n "$missing" ]; then
            echo "::error::Missing required configuration:$missing"
            echo "Please configure these in GitHub repository settings (Settings > Secrets and variables > Actions)"
            exit 1
          fi

          echo "✓ All required configuration present"

      - name: Create environment files
        env:
          DOMAIN: ${{ vars.DOMAIN }}
          ACME_EMAIL: ${{ vars.ACME_EMAIL }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          NEO4J_PASSWORD: ${{ secrets.NEO4J_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
          GOVERNANCE_PDS_JWT_SECRET: ${{ secrets.GOVERNANCE_PDS_JWT_SECRET }}
          GOVERNANCE_PDS_ADMIN_PASSWORD: ${{ secrets.GOVERNANCE_PDS_ADMIN_PASSWORD }}
          GOVERNANCE_PDS_ROTATION_KEY: ${{ secrets.GOVERNANCE_PDS_ROTATION_KEY }}
          TRAEFIK_BASIC_AUTH: ${{ secrets.TRAEFIK_BASIC_AUTH }}
          ATPROTO_SERVICE_DID: ${{ vars.ATPROTO_SERVICE_DID }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
          EMAIL_FROM: ${{ vars.EMAIL_FROM }}
          ZULIP_SERVER_URL: ${{ vars.ZULIP_SERVER_URL }}
          ZULIP_BOT_EMAIL: ${{ secrets.ZULIP_BOT_EMAIL }}
          ZULIP_BOT_API_KEY: ${{ secrets.ZULIP_BOT_API_KEY }}
          ZULIP_INVITE_URL: ${{ secrets.ZULIP_INVITE_URL }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
        run: |
          mkdir -p docker-env

          # Create .env for docker-compose variable interpolation
          cat > docker-env/.env <<EOF
          DOMAIN=${DOMAIN}
          ACME_EMAIL=${ACME_EMAIL}
          CHIVE_VERSION=latest
          POSTGRES_DB=chive
          POSTGRES_USER=chive
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          NEO4J_USER=neo4j
          NEO4J_PASSWORD=${NEO4J_PASSWORD}
          GOVERNANCE_PDS_JWT_SECRET=${GOVERNANCE_PDS_JWT_SECRET}
          GOVERNANCE_PDS_ADMIN_PASSWORD=${GOVERNANCE_PDS_ADMIN_PASSWORD}
          GOVERNANCE_PDS_ROTATION_KEY=${GOVERNANCE_PDS_ROTATION_KEY}
          TRAEFIK_BASIC_AUTH=${TRAEFIK_BASIC_AUTH}
          GRAFANA_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD}
          EOF

          # Create .env.production for container runtime
          cat > docker-env/.env.production <<EOF
          DOMAIN=${DOMAIN}
          ACME_EMAIL=${ACME_EMAIL}
          CHIVE_VERSION=latest
          POSTGRES_HOST=postgres
          POSTGRES_DB=chive
          POSTGRES_USER=chive
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          NEO4J_USER=neo4j
          NEO4J_PASSWORD=${NEO4J_PASSWORD}
          REDIS_URL=redis://redis:6379
          JWT_SECRET=${JWT_SECRET}
          SESSION_SECRET=${SESSION_SECRET}
          GOVERNANCE_PDS_JWT_SECRET=${GOVERNANCE_PDS_JWT_SECRET}
          GOVERNANCE_PDS_ADMIN_PASSWORD=${GOVERNANCE_PDS_ADMIN_PASSWORD}
          GOVERNANCE_PDS_ROTATION_KEY=${GOVERNANCE_PDS_ROTATION_KEY}
          DATABASE_URL=postgresql://chive:${POSTGRES_PASSWORD}@postgres:5432/chive
          ELASTICSEARCH_URL=http://elasticsearch:9200
          NEO4J_URI=bolt://neo4j:7687
          NEO4J_ENCRYPTED=ENCRYPTION_OFF
          ATPROTO_SERVICE_DID=${ATPROTO_SERVICE_DID}
          ATPROTO_RELAY_URL=wss://bsky.network
          SMTP_HOST=${SMTP_HOST}
          SMTP_PORT=${SMTP_PORT}
          SMTP_USER=${SMTP_USER}
          SMTP_PASSWORD=${SMTP_PASSWORD}
          EMAIL_FROM=${EMAIL_FROM}
          ZULIP_SERVER_URL=${ZULIP_SERVER_URL}
          ZULIP_BOT_EMAIL=${ZULIP_BOT_EMAIL}
          ZULIP_BOT_API_KEY=${ZULIP_BOT_API_KEY}
          ZULIP_INVITE_URL=${ZULIP_INVITE_URL}
          TRAEFIK_BASIC_AUTH=${TRAEFIK_BASIC_AUTH}
          EOF

          # Remove leading whitespace
          sed -i 's/^          //' docker-env/.env docker-env/.env.production

          echo "Created environment files:"
          ls -la docker-env/

      - name: Copy env files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "docker-env/.env,docker-env/.env.production"
          target: "/tmp/chive-deploy"
          strip_components: 1

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 30m
          script: |
            set -e

            DEPLOY_DIR="/opt/chive"
            REPO_URL="https://github.com/chive-pub/chive.git"

            echo "=== Starting deployment ==="
            echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

            # Ensure /opt exists and is writable
            sudo mkdir -p /opt
            sudo chown $USER:$USER /opt 2>/dev/null || true

            # Clone or update repository
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Cloning repository for initial setup..."
              git clone "$REPO_URL" "$DEPLOY_DIR"
            elif [ ! -d "$DEPLOY_DIR/.git" ]; then
              echo "Directory exists but is not a git repo. Removing and cloning..."
              rm -rf "$DEPLOY_DIR"
              git clone "$REPO_URL" "$DEPLOY_DIR"
            else
              echo "Updating existing repository..."
              cd "$DEPLOY_DIR"
              git fetch origin main
              git reset --hard origin/main
            fi

            cd "$DEPLOY_DIR"
            echo "Current commit: $(git rev-parse --short HEAD) - $(git log -1 --format=%s)"

            # Ensure docker directory exists and move env files
            mkdir -p docker
            echo "Moving env files..."
            mv /tmp/chive-deploy/.env docker/.env
            mv /tmp/chive-deploy/.env.production docker/.env.production
            rm -rf /tmp/chive-deploy

            # Build and deploy
            echo "=== Building and deploying containers ==="
            cd docker

            # Pull latest base images (including observability stack)
            echo "Pulling latest base images..."
            docker compose -f docker-compose.prod.yml --profile observability pull postgres redis elasticsearch neo4j traefik alloy tempo loki prometheus grafana || true

            # Build the main chive image (API + Indexer) - must target production stage
            # --no-cache ensures lexicons are regenerated from latest schemas
            echo "Building main chive image..."
            docker build --no-cache --target production -t chive:latest -f ../docker/Dockerfile .. || {
              echo "::error::Failed to build main chive image"
              exit 1
            }

            # Build web container (--no-cache ensures lexicons are regenerated)
            echo "Building chive-web container..."
            docker compose -f docker-compose.prod.yml build --no-cache chive-web || {
              echo "::error::Failed to build chive-web image"
              exit 1
            }

            # Note: chive-docs is deployed separately via deploy-docs.yml workflow

            # Start all services including observability stack
            # --force-recreate ensures containers use the newly built images
            echo "Starting services with observability..."
            docker compose -f docker-compose.prod.yml --profile observability up -d --force-recreate

            # Wait for services to initialize
            echo "Waiting for services to initialize..."
            sleep 30

            # Show running containers
            echo "=== Container status ==="
            docker compose -f docker-compose.prod.yml --profile observability ps

            # Check for any failed containers
            failed=$(docker compose -f docker-compose.prod.yml --profile observability ps --status exited --format json 2>/dev/null | grep -c '"State":"exited"' || echo "0")
            if [ "$failed" != "0" ]; then
              echo "::warning::Some containers may have exited"
              docker compose -f docker-compose.prod.yml --profile observability logs --tail=50 2>&1 | head -100
            fi

            # Cleanup old images
            echo "Cleaning up old images..."
            docker system prune -f

            echo "=== Deployment complete ==="
            echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

      - name: Setup Governance PDS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 5m
          script: |
            set -e

            DOMAIN="${{ vars.DOMAIN }}"
            PDS_CONTAINER="chive-governance-pds"
            GOVERNANCE_HANDLE="governance.${DOMAIN}"
            GOVERNANCE_EMAIL="governance@${DOMAIN}"

            echo "=== Governance PDS Setup ==="

            cd /opt/chive/docker

            # Wait for PDS to be healthy
            echo "Waiting for Governance PDS to be healthy..."
            for i in {1..30}; do
              if docker exec ${PDS_CONTAINER} wget -q --spider http://localhost:3000/xrpc/_health 2>/dev/null; then
                echo "✓ Governance PDS is healthy"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "::warning::Governance PDS not healthy after 60s - skipping account setup"
                exit 0
              fi
              sleep 2
            done

            # Check if governance account already exists by trying to resolve the handle
            echo "Checking if governance account exists..."
            EXISTING_DID=$(docker exec ${PDS_CONTAINER} sh -c "
              wget -q -O- 'http://localhost:3000/xrpc/com.atproto.identity.resolveHandle?handle=${GOVERNANCE_HANDLE}' 2>/dev/null || echo ''
            " | grep -o '"did":"[^"]*"' | cut -d'"' -f4 || echo "")

            if [ -n "$EXISTING_DID" ] && [ "$EXISTING_DID" != "" ]; then
              echo "✓ Governance account already exists"
              echo "  DID: ${EXISTING_DID}"
              echo "  Handle: ${GOVERNANCE_HANDLE}"
              exit 0
            fi

            # Create governance account using pdsadmin
            echo "Creating governance account..."
            echo "  Handle: ${GOVERNANCE_HANDLE}"
            echo "  Email: ${GOVERNANCE_EMAIL}"

            # Check if pdsadmin exists
            if docker exec ${PDS_CONTAINER} test -f /pds/pdsadmin.sh; then
              RESULT=$(docker exec ${PDS_CONTAINER} /pds/pdsadmin.sh account create "${GOVERNANCE_HANDLE}" "${GOVERNANCE_EMAIL}" 2>&1) || {
                echo "::warning::Failed to create governance account"
                echo "$RESULT"
                exit 0
              }
              echo "$RESULT"

              # Try to extract DID
              NEW_DID=$(echo "$RESULT" | grep -o 'did:plc:[a-z0-9]*' | head -1 || echo "")
              if [ -n "$NEW_DID" ]; then
                echo ""
                echo "✓ Governance account created!"
                echo "  DID: ${NEW_DID}"
                echo "  Handle: ${GOVERNANCE_HANDLE}"
              fi
            else
              echo "::warning::pdsadmin.sh not found in container - manual setup may be required"
            fi

      - name: Sync Governance PDS to Neo4j
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.APP_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          command_timeout: 10m
          script: |
            set -e

            echo "=== Syncing Governance PDS records to Neo4j ==="

            cd /opt/chive

            # Run the reindex script inside the chive-api container
            # The script syncs all pub.chive.graph.node and pub.chive.graph.edge records
            docker exec \
              -e GOVERNANCE_PDS_URL=http://governance-pds:3000 \
              -e GOVERNANCE_DID=${{ vars.GOVERNANCE_DID }} \
              -e GOVERNANCE_HANDLE=${{ vars.GOVERNANCE_HANDLE }} \
              -e GOVERNANCE_PASSWORD=${{ secrets.GOVERNANCE_PDS_ADMIN_PASSWORD }} \
              -e NEO4J_URI=bolt://neo4j:7687 \
              -e NEO4J_USER=neo4j \
              -e NEO4J_PASSWORD=${{ secrets.NEO4J_PASSWORD }} \
              chive-api \
              node --enable-source-maps dist/scripts/db/reindex-governance-to-neo4j.js || {
                echo "::warning::Governance sync failed - this may be expected on first deploy before records exist"
              }

            echo "=== Governance sync complete ==="

      - name: Verify deployment
        if: ${{ vars.DOMAIN != '' }}
        run: |
          echo "Waiting for services to fully start..."
          sleep 60

          domain="${{ vars.DOMAIN }}"
          success=true

          echo "Checking API health at https://$domain/api/health..."
          if curl -sf --max-time 30 "https://$domain/api/health"; then
            echo "✓ API health check passed"
          else
            echo "✗ API health check failed"
            success=false
          fi

          echo ""
          echo "Checking web frontend at https://$domain/..."
          if curl -sf --max-time 30 "https://$domain/" > /dev/null; then
            echo "✓ Web health check passed"
          else
            echo "✗ Web health check failed"
            success=false
          fi

          echo ""
          echo "Checking docs at https://docs.$domain/..."
          if curl -sf --max-time 30 "https://docs.$domain/" > /dev/null; then
            echo "✓ Docs health check passed"
          else
            echo "⚠ Docs health check failed (non-critical)"
          fi

          echo ""
          echo "Checking Grafana at https://grafana.$domain/..."
          if curl -sf --max-time 30 "https://grafana.$domain/api/health" > /dev/null; then
            echo "✓ Grafana health check passed"
          else
            echo "⚠ Grafana health check failed (non-critical)"
          fi

          echo ""
          echo "Checking Faro collector at https://faro.$domain/..."
          if curl -sf --max-time 30 "https://faro.$domain/ready" > /dev/null 2>&1 || curl -sf --max-time 30 -X OPTIONS "https://faro.$domain/collect" > /dev/null 2>&1; then
            echo "✓ Faro collector health check passed"
          else
            echo "⚠ Faro collector health check failed (non-critical)"
          fi

          echo ""
          if [ "$success" = "false" ]; then
            echo "::warning::Some health checks failed. Check container logs on the server."
          else
            echo "All critical health checks passed!"
          fi
