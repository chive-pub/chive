/**
 * User activity logging tables migration.
 *
 * @remarks
 * Creates tables for logging user-initiated write actions and correlating
 * them with firehose events for complete audit trail.
 *
 * Tables created:
 * - `user_activities` - User-initiated write actions with firehose correlation
 *
 * **Correlation Strategy:**
 * When a user initiates a write action via Chive UI:
 * 1. Frontend generates rkey (TID) and logs to user_activities with status='pending'
 * 2. Firehose indexer receives record with (repo, collection, rkey)
 * 3. Indexer looks up pending activity by (actor_did, collection, rkey)
 * 4. Activity updated to status='confirmed' with firehose URI/CID
 *
 * **Industry Standards:**
 * - W3C Trace Context compatible (trace_id, span_id for OpenTelemetry)
 * - Event sourcing pattern (immutable logs, no updates except status)
 * - GDPR compliant (user deletion cascades to activities)
 *
 * ATProto Compliance Notes:
 * - All data is AppView-specific (ephemeral, rebuildable from firehose)
 * - Activities rebuildable by replaying firehose with session correlation
 * - User DIDs optional for anonymous actions (session correlation only)
 *
 * @packageDocumentation
 */

import type { MigrationBuilder, ColumnDefinitions } from 'node-pg-migrate';

export const shorthands: ColumnDefinitions | undefined = undefined;

/**
 * Apply migration: create activity logging tables.
 *
 * @param pgm - PostgreSQL migration builder
 */
export function up(pgm: MigrationBuilder): void {
  // =============================================================
  // USER ACTIVITIES TABLE
  // =============================================================
  // Records user-initiated write actions with firehose correlation.
  // Uses (actor_did, collection, rkey) as correlation key since
  // rkey is generated client-side using TIDs.
  // =============================================================

  pgm.createTable('user_activities', {
    id: {
      type: 'uuid',
      primaryKey: true,
      default: pgm.func('gen_random_uuid()'),
      comment: 'Unique activity identifier',
    },

    // Correlation fields (for matching with firehose)
    actor_did: {
      type: 'varchar(255)',
      notNull: true,
      comment: 'DID of user who initiated the action',
    },
    collection: {
      type: 'varchar(255)',
      notNull: true,
      comment: 'NSID of the record collection (e.g., pub.chive.eprint.submission)',
    },
    rkey: {
      type: 'varchar(255)',
      notNull: true,
      comment: 'Record key (TID generated by frontend)',
    },

    // Action details
    action: {
      type: 'varchar(20)',
      notNull: true,
      check: "action IN ('create', 'update', 'delete')",
      comment: 'Action type',
    },
    action_category: {
      type: 'varchar(50)',
      notNull: true,
      comment: 'Semantic category (eprint_submit, review_create, endorsement_create, etc.)',
    },

    // Status tracking
    status: {
      type: 'varchar(20)',
      notNull: true,
      default: "'pending'",
      check: "status IN ('pending', 'confirmed', 'failed', 'timeout')",
      comment:
        'Activity status: pending (awaiting firehose), confirmed (firehose received), failed, timeout',
    },

    // Timestamps
    initiated_at: {
      type: 'timestamptz',
      notNull: true,
      default: pgm.func('NOW()'),
      comment: 'When user initiated the action in UI',
    },
    confirmed_at: {
      type: 'timestamptz',
      comment: 'When firehose event was received and correlated',
    },

    // Firehose correlation (filled when status=confirmed)
    firehose_seq: {
      type: 'bigint',
      comment: 'Firehose sequence number when confirmed',
    },
    firehose_uri: {
      type: 'varchar(512)',
      comment: 'AT URI of the record from firehose',
    },
    firehose_cid: {
      type: 'varchar(64)',
      comment: 'CID of the record from firehose',
    },

    // Target context (what was the action about)
    target_uri: {
      type: 'varchar(512)',
      comment: 'AT URI of target record (for reviews, endorsements targeting a eprint)',
    },
    target_title: {
      type: 'text',
      comment: 'Title/summary of target for display (denormalized)',
    },

    // OpenTelemetry tracing (W3C Trace Context)
    trace_id: {
      type: 'varchar(32)',
      comment: 'OpenTelemetry trace ID (16-byte hex)',
    },
    span_id: {
      type: 'varchar(16)',
      comment: 'OpenTelemetry span ID (8-byte hex)',
    },

    // Client context
    session_id: {
      type: 'varchar(64)',
      comment: 'Session identifier for grouping activities',
    },
    user_agent: {
      type: 'text',
      comment: 'Client user agent string',
    },
    ip_address: {
      type: 'inet',
      comment: 'Client IP address (hashed for privacy if needed)',
    },
    ui_context: {
      type: 'jsonb',
      default: '{}',
      comment: 'UI context (page, component, etc.) for debugging',
    },

    // Failure tracking
    error_code: {
      type: 'varchar(50)',
      comment: 'Error code if status=failed',
    },
    error_message: {
      type: 'text',
      comment: 'Error message if status=failed',
    },

    // Record snapshot (for audit purposes)
    record_snapshot: {
      type: 'jsonb',
      comment: 'Snapshot of record data at time of action (for audit trail)',
    },
  });

  // =============================================================
  // INDEXES
  // =============================================================

  // Primary correlation index: lookup by (actor_did, collection, rkey)
  // Used by firehose indexer to find pending activities
  pgm.createIndex('user_activities', ['actor_did', 'collection', 'rkey'], {
    name: 'idx_activities_correlation',
  });

  // Status index for finding pending activities to timeout
  pgm.createIndex('user_activities', 'status', {
    name: 'idx_activities_status',
    where: "status = 'pending'",
  });

  // User activity timeline
  pgm.createIndex('user_activities', ['actor_did', 'initiated_at'], {
    name: 'idx_activities_user_timeline',
  });

  // Action category for analytics
  pgm.createIndex('user_activities', 'action_category', {
    name: 'idx_activities_category',
  });

  // Firehose sequence for correlation verification
  pgm.createIndex('user_activities', 'firehose_seq', {
    name: 'idx_activities_firehose_seq',
    where: 'firehose_seq IS NOT NULL',
  });

  // Session grouping
  pgm.createIndex('user_activities', 'session_id', {
    name: 'idx_activities_session',
    where: 'session_id IS NOT NULL',
  });

  // Trace ID for distributed tracing
  pgm.createIndex('user_activities', 'trace_id', {
    name: 'idx_activities_trace',
    where: 'trace_id IS NOT NULL',
  });

  // Time-based partitioning support (for future optimization)
  pgm.createIndex('user_activities', 'initiated_at', {
    name: 'idx_activities_initiated_at',
  });

  // =============================================================
  // HELPER FUNCTION: Correlate firehose event with pending activity
  // =============================================================

  pgm.sql(`
    CREATE OR REPLACE FUNCTION correlate_activity(
      p_actor_did varchar(255),
      p_collection varchar(255),
      p_rkey varchar(255),
      p_firehose_seq bigint,
      p_firehose_uri varchar(512),
      p_firehose_cid varchar(64)
    )
    RETURNS uuid AS $$
    DECLARE
      v_activity_id uuid;
    BEGIN
      -- Find the most recent pending activity for this record
      SELECT id INTO v_activity_id
      FROM user_activities
      WHERE
        actor_did = p_actor_did
        AND collection = p_collection
        AND rkey = p_rkey
        AND status = 'pending'
        AND initiated_at > NOW() - INTERVAL '1 hour'
      ORDER BY initiated_at DESC
      LIMIT 1
      FOR UPDATE SKIP LOCKED;

      -- Update if found
      IF v_activity_id IS NOT NULL THEN
        UPDATE user_activities
        SET
          status = 'confirmed',
          confirmed_at = NOW(),
          firehose_seq = p_firehose_seq,
          firehose_uri = p_firehose_uri,
          firehose_cid = p_firehose_cid
        WHERE id = v_activity_id;
      END IF;

      RETURN v_activity_id;
    END;
    $$ LANGUAGE plpgsql;
  `);

  // =============================================================
  // HELPER FUNCTION: Timeout stale pending activities
  // =============================================================

  pgm.sql(`
    CREATE OR REPLACE FUNCTION timeout_stale_activities(
      p_timeout_interval interval DEFAULT '1 hour'
    )
    RETURNS integer AS $$
    DECLARE
      v_count integer;
    BEGIN
      UPDATE user_activities
      SET
        status = 'timeout',
        error_code = 'FIREHOSE_TIMEOUT',
        error_message = 'Activity not confirmed via firehose within timeout period'
      WHERE
        status = 'pending'
        AND initiated_at < NOW() - p_timeout_interval;

      GET DIAGNOSTICS v_count = ROW_COUNT;
      RETURN v_count;
    END;
    $$ LANGUAGE plpgsql;
  `);

  // =============================================================
  // VIEW: Activity feed with firehose correlation status
  // =============================================================

  pgm.sql(`
    CREATE OR REPLACE VIEW v_activity_feed AS
    SELECT
      id,
      actor_did,
      action,
      action_category,
      status,
      initiated_at,
      confirmed_at,
      firehose_uri,
      target_uri,
      target_title,
      -- Latency from UI action to firehose confirmation
      EXTRACT(EPOCH FROM (confirmed_at - initiated_at)) * 1000 AS latency_ms,
      -- Whether activity was confirmed within SLA (5 seconds)
      CASE
        WHEN status = 'confirmed' AND confirmed_at - initiated_at < INTERVAL '5 seconds' THEN true
        WHEN status = 'confirmed' THEN false
        ELSE NULL
      END AS within_sla
    FROM user_activities
    ORDER BY initiated_at DESC;
  `);

  // =============================================================
  // VIEW: Activity correlation metrics
  // =============================================================

  pgm.sql(`
    CREATE OR REPLACE VIEW v_activity_correlation_metrics AS
    SELECT
      date_trunc('hour', initiated_at) AS hour,
      action_category,
      COUNT(*) AS total_activities,
      COUNT(*) FILTER (WHERE status = 'confirmed') AS confirmed,
      COUNT(*) FILTER (WHERE status = 'failed') AS failed,
      COUNT(*) FILTER (WHERE status = 'timeout') AS timeout,
      COUNT(*) FILTER (WHERE status = 'pending') AS pending,
      -- Confirmation rate
      ROUND(
        100.0 * COUNT(*) FILTER (WHERE status = 'confirmed') / NULLIF(COUNT(*), 0),
        2
      ) AS confirmation_rate_pct,
      -- Average latency for confirmed activities
      AVG(EXTRACT(EPOCH FROM (confirmed_at - initiated_at)) * 1000)
        FILTER (WHERE status = 'confirmed') AS avg_latency_ms,
      -- P95 latency
      percentile_cont(0.95) WITHIN GROUP (ORDER BY EXTRACT(EPOCH FROM (confirmed_at - initiated_at)) * 1000)
        FILTER (WHERE status = 'confirmed') AS p95_latency_ms
    FROM user_activities
    WHERE initiated_at > NOW() - INTERVAL '7 days'
    GROUP BY date_trunc('hour', initiated_at), action_category
    ORDER BY hour DESC, action_category;
  `);

  // =============================================================
  // COMMENTS
  // =============================================================

  pgm.sql(
    `COMMENT ON TABLE user_activities IS 'User-initiated write actions with firehose correlation for audit trail'`
  );
  pgm.sql(
    `COMMENT ON FUNCTION correlate_activity IS 'Links firehose event to pending user activity'`
  );
  pgm.sql(
    `COMMENT ON FUNCTION timeout_stale_activities IS 'Marks pending activities as timed out'`
  );
}

/**
 * Rollback migration: drop activity logging tables.
 *
 * @param pgm - PostgreSQL migration builder
 */
export function down(pgm: MigrationBuilder): void {
  pgm.sql('DROP VIEW IF EXISTS v_activity_correlation_metrics');
  pgm.sql('DROP VIEW IF EXISTS v_activity_feed');
  pgm.sql('DROP FUNCTION IF EXISTS timeout_stale_activities(interval)');
  pgm.sql(
    'DROP FUNCTION IF EXISTS correlate_activity(varchar, varchar, varchar, bigint, varchar, varchar)'
  );
  pgm.dropTable('user_activities', { ifExists: true, cascade: true });
}
