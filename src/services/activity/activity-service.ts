/**
 * Activity logging service for tracking user actions with firehose correlation.
 *
 * @remarks
 * Provides comprehensive activity logging that correlates UI-initiated write
 * actions with their corresponding firehose events.
 *
 * **Industry Standard Approach:**
 * - W3C Trace Context compatible (trace_id, span_id for OpenTelemetry)
 * - Event sourcing pattern (immutable activity records)
 * - GDPR compliant (user deletion cascades to activities)
 *
 * **Correlation Strategy:**
 * When a user initiates a write action via Chive UI:
 * 1. Frontend generates rkey (TID) and calls logActivity()
 * 2. Activity stored with status='pending'
 * 3. Firehose indexer receives record with (repo, collection, rkey)
 * 4. Indexer calls correlateWithFirehose() to update status='confirmed'
 *
 * **ATProto Compliance:**
 * - All activity logs are AppView-specific (ephemeral)
 * - Rebuildable from firehose by replaying with session correlation
 * - No PDS writes or mutations
 *
 * @packageDocumentation
 * @public
 */

import type { Pool } from 'pg';

import type { AtUri, CID, DID, NSID } from '../../types/atproto.js';
import { DatabaseError } from '../../types/errors.js';
import type { ILogger } from '../../types/interfaces/logger.interface.js';
import type { Result } from '../../types/result.js';

/**
 * Activity action types.
 *
 * @public
 */
export type ActivityAction = 'create' | 'update' | 'delete';

/**
 * Activity status.
 *
 * @public
 */
export type ActivityStatus = 'pending' | 'confirmed' | 'failed' | 'timeout';

/**
 * Semantic activity categories.
 *
 * @public
 */
export type ActivityCategory =
  | 'eprint_submit'
  | 'eprint_update'
  | 'eprint_delete'
  | 'review_create'
  | 'review_update'
  | 'review_delete'
  | 'endorsement_create'
  | 'endorsement_delete'
  | 'tag_create'
  | 'tag_delete'
  | 'profile_update'
  | 'proposal_create'
  | 'vote_create';

/**
 * Activity logging input.
 *
 * @public
 */
export interface LogActivityInput {
  /**
   * DID of user who initiated the action.
   */
  readonly actorDid: DID;

  /**
   * Record collection NSID.
   */
  readonly collection: NSID;

  /**
   * Record key (TID generated by frontend).
   */
  readonly rkey: string;

  /**
   * Action type.
   */
  readonly action: ActivityAction;

  /**
   * Semantic category for analytics.
   */
  readonly category: ActivityCategory;

  /**
   * Target record URI (for reviews, endorsements targeting an eprint).
   */
  readonly targetUri?: AtUri;

  /**
   * Target record title for display.
   */
  readonly targetTitle?: string;

  /**
   * OpenTelemetry trace ID (W3C Trace Context).
   */
  readonly traceId?: string;

  /**
   * OpenTelemetry span ID (W3C Trace Context).
   */
  readonly spanId?: string;

  /**
   * Session identifier for grouping activities.
   */
  readonly sessionId?: string;

  /**
   * Client user agent.
   */
  readonly userAgent?: string;

  /**
   * Client IP address.
   */
  readonly ipAddress?: string;

  /**
   * UI context metadata for debugging.
   */
  readonly uiContext?: Record<string, unknown>;

  /**
   * Record snapshot for audit purposes.
   */
  readonly recordSnapshot?: Record<string, unknown>;
}

/**
 * Firehose correlation input.
 *
 * @public
 */
export interface CorrelateFirehoseInput {
  /**
   * Repository DID (actor who created the record).
   */
  readonly repo: DID;

  /**
   * Record collection NSID.
   */
  readonly collection: NSID;

  /**
   * Record key.
   */
  readonly rkey: string;

  /**
   * Firehose sequence number.
   */
  readonly seq: number;

  /**
   * AT URI of the record.
   */
  readonly uri: AtUri;

  /**
   * Record CID.
   */
  readonly cid: CID;
}

/**
 * Logged activity record.
 *
 * @public
 */
export interface Activity {
  readonly id: string;
  readonly actorDid: DID;
  readonly collection: NSID;
  readonly rkey: string;
  readonly action: ActivityAction;
  readonly category: ActivityCategory;
  readonly status: ActivityStatus;
  readonly initiatedAt: Date;
  readonly confirmedAt: Date | null;
  readonly firehoseSeq: number | null;
  readonly firehoseUri: AtUri | null;
  readonly firehoseCid: CID | null;
  readonly targetUri: AtUri | null;
  readonly targetTitle: string | null;
  readonly traceId: string | null;
  readonly spanId: string | null;
  readonly sessionId: string | null;
  readonly errorCode: string | null;
  readonly errorMessage: string | null;
}

/**
 * Activity feed query options.
 *
 * @public
 */
export interface ActivityFeedOptions {
  /**
   * Filter by actor DID.
   */
  readonly actorDid?: DID;

  /**
   * Filter by category.
   */
  readonly category?: ActivityCategory;

  /**
   * Filter by status.
   */
  readonly status?: ActivityStatus;

  /**
   * Maximum number of results.
   */
  readonly limit?: number;

  /**
   * Cursor for pagination.
   */
  readonly cursor?: string;
}

/**
 * Activity correlation metrics.
 *
 * @public
 */
export interface CorrelationMetrics {
  readonly hour: Date;
  readonly category: ActivityCategory;
  readonly total: number;
  readonly confirmed: number;
  readonly failed: number;
  readonly timeout: number;
  readonly pending: number;
  readonly confirmationRatePct: number;
  readonly avgLatencyMs: number | null;
  readonly p95LatencyMs: number | null;
}

/**
 * Activity log service configuration.
 *
 * @public
 */
export interface ActivityServiceOptions {
  /**
   * PostgreSQL connection pool.
   */
  readonly pool: Pool;

  /**
   * Logger instance.
   */
  readonly logger: ILogger;

  /**
   * Timeout interval for stale activities (default: 1 hour).
   */
  readonly timeoutInterval?: string;
}

/**
 * Activity logging service.
 *
 * @remarks
 * Provides comprehensive activity logging with firehose correlation.
 *
 * **Usage Pattern:**
 * ```typescript
 * // Frontend initiates PDS write
 * const rkey = TID.next();
 *
 * // Log activity before PDS write
 * await activityService.logActivity({
 *   actorDid: userDid,
 *   collection: 'pub.chive.eprint.submission',
 *   rkey,
 *   action: 'create',
 *   category: 'eprint_submit',
 *   traceId,
 *   sessionId,
 * });
 *
 * // Frontend performs PDS write...
 *
 * // Firehose indexer receives event and correlates
 * await activityService.correlateWithFirehose({
 *   repo: event.repo,
 *   collection: 'pub.chive.eprint.submission',
 *   rkey: event.rkey,
 *   seq: event.seq,
 *   uri: constructedUri,
 *   cid: event.cid,
 * });
 * ```
 *
 * @public
 */
export class ActivityService {
  private readonly pool: Pool;
  private readonly logger: ILogger;
  private readonly timeoutInterval: string;

  constructor(options: ActivityServiceOptions) {
    this.pool = options.pool;
    this.logger = options.logger;
    this.timeoutInterval = options.timeoutInterval ?? '1 hour';
  }

  /**
   * Logs a user-initiated activity.
   *
   * @param input - Activity details
   * @returns Result with activity ID or error
   *
   * @remarks
   * Called by frontend before performing PDS write. The activity is stored
   * with status='pending' until the firehose event is received and correlated.
   *
   * @public
   */
  async logActivity(input: LogActivityInput): Promise<Result<string, DatabaseError>> {
    try {
      const result = await this.pool.query<{ id: string }>(
        `INSERT INTO user_activities (
          actor_did,
          collection,
          rkey,
          action,
          action_category,
          target_uri,
          target_title,
          trace_id,
          span_id,
          session_id,
          user_agent,
          ip_address,
          ui_context,
          record_snapshot
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        RETURNING id`,
        [
          input.actorDid,
          input.collection,
          input.rkey,
          input.action,
          input.category,
          input.targetUri ?? null,
          input.targetTitle ?? null,
          input.traceId ?? null,
          input.spanId ?? null,
          input.sessionId ?? null,
          input.userAgent ?? null,
          input.ipAddress ?? null,
          input.uiContext ? JSON.stringify(input.uiContext) : '{}',
          input.recordSnapshot ? JSON.stringify(input.recordSnapshot) : null,
        ]
      );

      const activityId = result.rows[0]?.id;
      if (!activityId) {
        return {
          ok: false,
          error: new DatabaseError('WRITE', 'Failed to create activity record'),
        };
      }

      this.logger.debug('Logged activity', {
        id: activityId,
        actor: input.actorDid,
        collection: input.collection,
        rkey: input.rkey,
        category: input.category,
      });

      return { ok: true, value: activityId };
    } catch (error) {
      this.logger.error('Failed to log activity', error instanceof Error ? error : undefined, {
        actor: input.actorDid,
        collection: input.collection,
        rkey: input.rkey,
      });

      return {
        ok: false,
        error: new DatabaseError(
          'WRITE',
          error instanceof Error ? error.message : `Failed to log activity: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Correlates a firehose event with a pending activity.
   *
   * @param input - Firehose event details
   * @returns Result with activity ID if correlated, null if no match
   *
   * @remarks
   * Called by the firehose indexer when processing commit events.
   * Uses (actor_did, collection, rkey) as correlation key.
   *
   * The correlation function only matches activities initiated within
   * the last hour to prevent false positives from stale data.
   *
   * @public
   */
  async correlateWithFirehose(
    input: CorrelateFirehoseInput
  ): Promise<Result<string | null, DatabaseError>> {
    try {
      const result = await this.pool.query<{ correlate_activity: string | null }>(
        `SELECT correlate_activity($1, $2, $3, $4, $5, $6)`,
        [input.repo, input.collection, input.rkey, input.seq, input.uri, input.cid]
      );

      const activityId = result.rows[0]?.correlate_activity ?? null;

      if (activityId) {
        this.logger.debug('Correlated activity with firehose', {
          activityId,
          repo: input.repo,
          collection: input.collection,
          rkey: input.rkey,
          seq: input.seq,
        });
      }

      return { ok: true, value: activityId };
    } catch (error) {
      this.logger.error(
        'Failed to correlate activity',
        error instanceof Error ? error : undefined,
        {
          repo: input.repo,
          collection: input.collection,
          rkey: input.rkey,
        }
      );

      return {
        ok: false,
        error: new DatabaseError(
          'WRITE',
          error instanceof Error ? error.message : `Failed to correlate activity: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Marks an activity as failed.
   *
   * @param actorDid - Actor DID
   * @param collection - Record collection
   * @param rkey - Record key
   * @param errorCode - Error code
   * @param errorMessage - Error message
   * @returns Result indicating success or failure
   *
   * @remarks
   * Called by frontend when PDS write fails.
   *
   * @public
   */
  async markFailed(
    actorDid: DID,
    collection: NSID,
    rkey: string,
    errorCode: string,
    errorMessage: string
  ): Promise<Result<void, DatabaseError>> {
    try {
      await this.pool.query(
        `UPDATE user_activities
         SET status = 'failed', error_code = $4, error_message = $5
         WHERE actor_did = $1 AND collection = $2 AND rkey = $3 AND status = 'pending'`,
        [actorDid, collection, rkey, errorCode, errorMessage]
      );

      this.logger.debug('Marked activity as failed', {
        actor: actorDid,
        collection,
        rkey,
        errorCode,
      });

      return { ok: true, value: undefined };
    } catch (error) {
      this.logger.error(
        'Failed to mark activity as failed',
        error instanceof Error ? error : undefined
      );

      return {
        ok: false,
        error: new DatabaseError(
          'WRITE',
          error instanceof Error
            ? error.message
            : `Failed to mark activity as failed: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Timeouts stale pending activities.
   *
   * @returns Result with count of timed out activities
   *
   * @remarks
   * Should be called periodically by a background job to mark old
   * pending activities as timed out (firehose confirmation never received).
   *
   * @public
   */
  async timeoutStaleActivities(): Promise<Result<number, DatabaseError>> {
    try {
      const result = await this.pool.query<{ timeout_stale_activities: number }>(
        `SELECT timeout_stale_activities($1::interval)`,
        [this.timeoutInterval]
      );

      const count = result.rows[0]?.timeout_stale_activities ?? 0;

      if (count > 0) {
        this.logger.info('Timed out stale activities', { count });
      }

      return { ok: true, value: count };
    } catch (error) {
      this.logger.error(
        'Failed to timeout stale activities',
        error instanceof Error ? error : undefined
      );

      return {
        ok: false,
        error: new DatabaseError(
          'WRITE',
          error instanceof Error
            ? error.message
            : `Failed to timeout stale activities: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Gets activity feed for a user.
   *
   * @param options - Query options
   * @returns Result with activities and cursor
   *
   * @public
   */
  async getActivityFeed(
    options: ActivityFeedOptions
  ): Promise<Result<{ activities: readonly Activity[]; cursor: string | null }, DatabaseError>> {
    try {
      const conditions: string[] = [];
      const params: unknown[] = [];
      let paramIndex = 1;

      if (options.actorDid) {
        conditions.push(`actor_did = $${paramIndex++}`);
        params.push(options.actorDid);
      }

      if (options.category) {
        conditions.push(`action_category = $${paramIndex++}`);
        params.push(options.category);
      }

      if (options.status) {
        conditions.push(`status = $${paramIndex++}`);
        params.push(options.status);
      }

      if (options.cursor) {
        conditions.push(`initiated_at < $${paramIndex++}`);
        params.push(new Date(options.cursor));
      }

      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
      const limit = options.limit ?? 50;
      params.push(limit + 1);

      const result = await this.pool.query<{
        id: string;
        actor_did: DID;
        collection: NSID;
        rkey: string;
        action: ActivityAction;
        action_category: ActivityCategory;
        status: ActivityStatus;
        initiated_at: Date;
        confirmed_at: Date | null;
        firehose_seq: string | null;
        firehose_uri: AtUri | null;
        firehose_cid: CID | null;
        target_uri: AtUri | null;
        target_title: string | null;
        trace_id: string | null;
        span_id: string | null;
        session_id: string | null;
        error_code: string | null;
        error_message: string | null;
      }>(
        `SELECT
          id, actor_did, collection, rkey, action, action_category, status,
          initiated_at, confirmed_at, firehose_seq, firehose_uri, firehose_cid,
          target_uri, target_title, trace_id, span_id, session_id,
          error_code, error_message
         FROM user_activities
         ${whereClause}
         ORDER BY initiated_at DESC
         LIMIT $${paramIndex}`,
        params
      );

      const hasMore = result.rows.length > limit;
      const rows = hasMore ? result.rows.slice(0, -1) : result.rows;

      const activities: Activity[] = rows.map((row) => ({
        id: row.id,
        actorDid: row.actor_did,
        collection: row.collection,
        rkey: row.rkey,
        action: row.action,
        category: row.action_category,
        status: row.status,
        initiatedAt: row.initiated_at,
        confirmedAt: row.confirmed_at,
        firehoseSeq: row.firehose_seq ? parseInt(row.firehose_seq, 10) : null,
        firehoseUri: row.firehose_uri,
        firehoseCid: row.firehose_cid,
        targetUri: row.target_uri,
        targetTitle: row.target_title,
        traceId: row.trace_id,
        spanId: row.span_id,
        sessionId: row.session_id,
        errorCode: row.error_code,
        errorMessage: row.error_message,
      }));

      const lastActivity = rows[rows.length - 1];
      const cursor = hasMore && lastActivity ? lastActivity.initiated_at.toISOString() : null;

      return { ok: true, value: { activities, cursor } };
    } catch (error) {
      this.logger.error('Failed to get activity feed', error instanceof Error ? error : undefined);

      return {
        ok: false,
        error: new DatabaseError(
          'READ',
          error instanceof Error ? error.message : `Failed to get activity feed: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Gets correlation metrics.
   *
   * @returns Result with correlation metrics by hour and category
   *
   * @public
   */
  async getCorrelationMetrics(): Promise<Result<readonly CorrelationMetrics[], DatabaseError>> {
    try {
      const result = await this.pool.query<{
        hour: Date;
        action_category: ActivityCategory;
        total_activities: string;
        confirmed: string;
        failed: string;
        timeout: string;
        pending: string;
        confirmation_rate_pct: string | null;
        avg_latency_ms: string | null;
        p95_latency_ms: string | null;
      }>(`SELECT * FROM v_activity_correlation_metrics`);

      const metrics: CorrelationMetrics[] = result.rows.map((row) => ({
        hour: row.hour,
        category: row.action_category,
        total: parseInt(row.total_activities, 10),
        confirmed: parseInt(row.confirmed, 10),
        failed: parseInt(row.failed, 10),
        timeout: parseInt(row.timeout, 10),
        pending: parseInt(row.pending, 10),
        confirmationRatePct: row.confirmation_rate_pct ? parseFloat(row.confirmation_rate_pct) : 0,
        avgLatencyMs: row.avg_latency_ms ? parseFloat(row.avg_latency_ms) : null,
        p95LatencyMs: row.p95_latency_ms ? parseFloat(row.p95_latency_ms) : null,
      }));

      return { ok: true, value: metrics };
    } catch (error) {
      this.logger.error(
        'Failed to get correlation metrics',
        error instanceof Error ? error : undefined
      );

      return {
        ok: false,
        error: new DatabaseError(
          'READ',
          error instanceof Error
            ? error.message
            : `Failed to get correlation metrics: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Gets activity by ID.
   *
   * @param id - Activity ID
   * @returns Result with activity or null if not found
   *
   * @public
   */
  async getActivity(id: string): Promise<Result<Activity | null, DatabaseError>> {
    try {
      const result = await this.pool.query<{
        id: string;
        actor_did: DID;
        collection: NSID;
        rkey: string;
        action: ActivityAction;
        action_category: ActivityCategory;
        status: ActivityStatus;
        initiated_at: Date;
        confirmed_at: Date | null;
        firehose_seq: string | null;
        firehose_uri: AtUri | null;
        firehose_cid: CID | null;
        target_uri: AtUri | null;
        target_title: string | null;
        trace_id: string | null;
        span_id: string | null;
        session_id: string | null;
        error_code: string | null;
        error_message: string | null;
      }>(
        `SELECT
          id, actor_did, collection, rkey, action, action_category, status,
          initiated_at, confirmed_at, firehose_seq, firehose_uri, firehose_cid,
          target_uri, target_title, trace_id, span_id, session_id,
          error_code, error_message
         FROM user_activities
         WHERE id = $1`,
        [id]
      );

      const row = result.rows[0];
      if (!row) {
        return { ok: true, value: null };
      }

      const activity: Activity = {
        id: row.id,
        actorDid: row.actor_did,
        collection: row.collection,
        rkey: row.rkey,
        action: row.action,
        category: row.action_category,
        status: row.status,
        initiatedAt: row.initiated_at,
        confirmedAt: row.confirmed_at,
        firehoseSeq: row.firehose_seq ? parseInt(row.firehose_seq, 10) : null,
        firehoseUri: row.firehose_uri,
        firehoseCid: row.firehose_cid,
        targetUri: row.target_uri,
        targetTitle: row.target_title,
        traceId: row.trace_id,
        spanId: row.span_id,
        sessionId: row.session_id,
        errorCode: row.error_code,
        errorMessage: row.error_message,
      };

      return { ok: true, value: activity };
    } catch (error) {
      this.logger.error('Failed to get activity', error instanceof Error ? error : undefined, {
        id,
      });

      return {
        ok: false,
        error: new DatabaseError(
          'READ',
          error instanceof Error ? error.message : `Failed to get activity: ${String(error)}`
        ),
      };
    }
  }

  /**
   * Batch correlates multiple firehose events (for efficiency).
   *
   * @param inputs - Array of firehose event details
   * @returns Result with map of rkey to activity ID
   *
   * @remarks
   * Use for batch processing when handling multiple events at once.
   *
   * @public
   */
  async batchCorrelate(
    inputs: readonly CorrelateFirehoseInput[]
  ): Promise<Result<Map<string, string>, DatabaseError>> {
    if (inputs.length === 0) {
      return { ok: true, value: new Map() };
    }

    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');

      const correlations = new Map<string, string>();

      for (const input of inputs) {
        const result = await client.query<{ correlate_activity: string | null }>(
          `SELECT correlate_activity($1, $2, $3, $4, $5, $6)`,
          [input.repo, input.collection, input.rkey, input.seq, input.uri, input.cid]
        );

        const activityId = result.rows[0]?.correlate_activity;
        if (activityId) {
          correlations.set(input.rkey, activityId);
        }
      }

      await client.query('COMMIT');

      this.logger.debug('Batch correlated activities', {
        total: inputs.length,
        correlated: correlations.size,
      });

      return { ok: true, value: correlations };
    } catch (error) {
      await client.query('ROLLBACK');

      this.logger.error('Failed to batch correlate', error instanceof Error ? error : undefined);

      return {
        ok: false,
        error: new DatabaseError(
          'WRITE',
          error instanceof Error ? error.message : `Failed to batch correlate: ${String(error)}`
        ),
      };
    } finally {
      client.release();
    }
  }

  /**
   * Gets pending activity count for monitoring.
   *
   * @returns Result with pending activity count
   *
   * @public
   */
  async getPendingCount(): Promise<Result<number, DatabaseError>> {
    try {
      const result = await this.pool.query<{ count: string }>(
        `SELECT COUNT(*) FROM user_activities WHERE status = 'pending'`
      );

      const count = parseInt(result.rows[0]?.count ?? '0', 10);
      return { ok: true, value: count };
    } catch (error) {
      this.logger.error('Failed to get pending count', error instanceof Error ? error : undefined);

      return {
        ok: false,
        error: new DatabaseError(
          'READ',
          error instanceof Error ? error.message : `Failed to get pending count: ${String(error)}`
        ),
      };
    }
  }
}
